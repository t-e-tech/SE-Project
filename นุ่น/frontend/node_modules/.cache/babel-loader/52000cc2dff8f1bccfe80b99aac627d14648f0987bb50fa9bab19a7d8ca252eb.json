{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useControlled from '@mui/utils/useControlled';\nimport { useTheme } from '@mui/material/styles';\nimport { useUtils, useLocaleText, useLocalizationContext } from '../useUtils';\nimport { addPositionPropertiesToSections, splitFormatIntoSections, clampDaySectionIfPossible, mergeDateIntoReferenceDate, getSectionsBoundaries, validateSections, getDateFromDateSections } from './useField.utils';\nexport const useFieldState = params => {\n  var _ref;\n  const utils = useUtils();\n  const localeText = useLocaleText();\n  const adapter = useLocalizationContext();\n  const theme = useTheme();\n  const isRTL = theme.direction === 'rtl';\n  const {\n    valueManager,\n    fieldValueManager,\n    valueType,\n    validator,\n    internalProps,\n    internalProps: {\n      value: valueProp,\n      defaultValue,\n      onChange,\n      format,\n      selectedSections: selectedSectionsProp,\n      onSelectedSectionsChange\n    }\n  } = params;\n  const firstDefaultValue = React.useRef(defaultValue);\n  const valueFromTheOutside = (_ref = valueProp != null ? valueProp : firstDefaultValue.current) != null ? _ref : valueManager.emptyValue;\n  const sectionsValueBoundaries = React.useMemo(() => getSectionsBoundaries(utils), [utils]);\n  const getSectionsFromValue = React.useCallback(function (value) {\n    let fallbackSections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return fieldValueManager.getSectionsFromValue(utils, value, fallbackSections, isRTL, date => splitFormatIntoSections(utils, localeText, format, date));\n  }, [fieldValueManager, format, localeText, isRTL, utils]);\n  const placeholder = React.useMemo(() => fieldValueManager.getValueStrFromSections(getSectionsFromValue(valueManager.emptyValue), isRTL), [fieldValueManager, getSectionsFromValue, valueManager.emptyValue, isRTL]);\n  const [state, setState] = React.useState(() => {\n    const sections = getSectionsFromValue(valueFromTheOutside);\n    validateSections(sections, valueType);\n    return {\n      sections,\n      value: valueFromTheOutside,\n      referenceValue: fieldValueManager.updateReferenceValue(utils, valueFromTheOutside, valueManager.getTodayValue(utils)),\n      tempValueStrAndroid: null\n    };\n  });\n  const [selectedSections, innerSetSelectedSections] = useControlled({\n    controlled: selectedSectionsProp,\n    default: null,\n    name: 'useField',\n    state: 'selectedSectionIndexes'\n  });\n  const setSelectedSections = newSelectedSections => {\n    innerSetSelectedSections(newSelectedSections);\n    onSelectedSectionsChange == null ? void 0 : onSelectedSectionsChange(newSelectedSections);\n    setState(prevState => _extends({}, prevState, {\n      selectedSectionQuery: null\n    }));\n  };\n  const selectedSectionIndexes = React.useMemo(() => {\n    if (selectedSections == null) {\n      return null;\n    }\n    if (selectedSections === 'all') {\n      return {\n        startIndex: 0,\n        endIndex: state.sections.length - 1,\n        shouldSelectBoundarySelectors: true\n      };\n    }\n    if (typeof selectedSections === 'number') {\n      return {\n        startIndex: selectedSections,\n        endIndex: selectedSections\n      };\n    }\n    if (typeof selectedSections === 'string') {\n      const selectedSectionIndex = state.sections.findIndex(section => section.type === selectedSections);\n      return {\n        startIndex: selectedSectionIndex,\n        endIndex: selectedSectionIndex\n      };\n    }\n    return selectedSections;\n  }, [selectedSections, state.sections]);\n  const publishValue = _ref2 => {\n    let {\n      value,\n      referenceValue,\n      sections\n    } = _ref2;\n    setState(prevState => _extends({}, prevState, {\n      sections,\n      value,\n      referenceValue,\n      tempValueStrAndroid: null\n    }));\n    if (onChange) {\n      const context = {\n        validationError: validator({\n          adapter,\n          value,\n          props: _extends({}, internalProps, {\n            value\n          })\n        })\n      };\n      onChange(value, context);\n    }\n  };\n  const setSectionValue = (sectionIndex, newSectionValue) => {\n    const newSections = [...state.sections];\n    newSections[sectionIndex] = _extends({}, newSections[sectionIndex], {\n      value: newSectionValue,\n      modified: true\n    });\n    return addPositionPropertiesToSections(newSections, isRTL);\n  };\n  const clearValue = () => {\n    if (valueManager.areValuesEqual(utils, state.value, valueManager.emptyValue)) {\n      return;\n    }\n    publishValue({\n      value: valueManager.emptyValue,\n      referenceValue: state.referenceValue,\n      sections: getSectionsFromValue(valueManager.emptyValue)\n    });\n  };\n  const clearActiveSection = () => {\n    if (selectedSectionIndexes == null) {\n      return;\n    }\n    const activeSection = state.sections[selectedSectionIndexes.startIndex];\n    if (activeSection.value === '') {\n      return;\n    }\n    const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);\n    const nonEmptySectionCountBefore = activeDateManager.getSections(state.sections).filter(section => section.value !== '').length;\n    const isTheOnlyNonEmptySection = nonEmptySectionCountBefore === 1;\n    const newSections = setSectionValue(selectedSectionIndexes.startIndex, '');\n    const newActiveDate = isTheOnlyNonEmptySection ? null : utils.date(new Date(''));\n    const newValues = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);\n    if ((newActiveDate != null && !utils.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils.isValid(activeDateManager.date))) {\n      publishValue(_extends({}, newValues, {\n        sections: newSections\n      }));\n    } else {\n      setState(prevState => _extends({}, prevState, newValues, {\n        sections: newSections,\n        tempValueStrAndroid: null\n      }));\n    }\n  };\n  const updateValueFromValueStr = valueStr => {\n    const parseDateStr = (dateStr, referenceDate) => {\n      const date = utils.parse(dateStr, format);\n      if (date == null || !utils.isValid(date)) {\n        return null;\n      }\n      const sections = splitFormatIntoSections(utils, localeText, format, date);\n      return mergeDateIntoReferenceDate(utils, date, sections, referenceDate, false);\n    };\n    const newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);\n    const newReferenceValue = fieldValueManager.updateReferenceValue(utils, newValue, state.referenceValue);\n    publishValue({\n      value: newValue,\n      referenceValue: newReferenceValue,\n      sections: getSectionsFromValue(newValue, state.sections)\n    });\n  };\n  const updateSectionValue = _ref3 => {\n    let {\n      activeSection,\n      newSectionValue,\n      shouldGoToNextSection\n    } = _ref3;\n    /**\n     * 1. Decide which section should be focused\n     */\n    if (shouldGoToNextSection && selectedSectionIndexes && selectedSectionIndexes.startIndex < state.sections.length - 1) {\n      setSelectedSections(selectedSectionIndexes.startIndex + 1);\n    } else if (selectedSectionIndexes && selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n      setSelectedSections(selectedSectionIndexes.startIndex);\n    }\n\n    /**\n     * 2. Try to build a valid date from the new section value\n     */\n    const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);\n    const newSections = setSectionValue(selectedSectionIndexes.startIndex, newSectionValue);\n    const newActiveDateSections = activeDateManager.getSections(newSections);\n    let newActiveDate = getDateFromDateSections(utils, newActiveDateSections);\n    let shouldRegenSections = false;\n\n    /**\n     * If the date is invalid,\n     * Then we can try to clamp the day section to see if that produces a valid date.\n     * This can be useful if the month has fewer days than the day value currently provided.\n     */\n    if (!utils.isValid(newActiveDate)) {\n      const clampedSections = clampDaySectionIfPossible(utils, newActiveDateSections, sectionsValueBoundaries);\n      if (clampedSections != null) {\n        shouldRegenSections = true;\n        newActiveDate = getDateFromDateSections(utils, clampedSections);\n      }\n    }\n    let values;\n    let shouldPublish;\n\n    /**\n     * If the new date is valid,\n     * Then we merge the value of the modified sections into the reference date.\n     * This makes sure that we don't lose some information of the initial date (like the time on a date field).\n     */\n    if (newActiveDate != null && utils.isValid(newActiveDate)) {\n      const mergedDate = mergeDateIntoReferenceDate(utils, newActiveDate, newActiveDateSections, activeDateManager.referenceDate, true);\n      values = activeDateManager.getNewValuesFromNewActiveDate(mergedDate);\n      shouldPublish = true;\n    } else {\n      values = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);\n      shouldPublish = (newActiveDate != null && !utils.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils.isValid(activeDateManager.date));\n    }\n\n    /**\n     * If the value has been modified (to clamp the day).\n     * Then we need to re-generate the sections to make sure they also have this change.\n     */\n    const sections = shouldRegenSections ? getSectionsFromValue(values.value, state.sections) : newSections;\n\n    /**\n     * Publish or update the internal state with the new value and sections.\n     */\n    if (shouldPublish) {\n      return publishValue(_extends({}, values, {\n        sections\n      }));\n    }\n    return setState(prevState => _extends({}, prevState, values, {\n      sections,\n      tempValueStrAndroid: null\n    }));\n  };\n  const setTempAndroidValueStr = tempValueStrAndroid => setState(prev => _extends({}, prev, {\n    tempValueStrAndroid\n  }));\n  React.useEffect(() => {\n    if (!valueManager.areValuesEqual(utils, state.value, valueFromTheOutside)) {\n      setState(prevState => _extends({}, prevState, {\n        value: valueFromTheOutside,\n        referenceValue: fieldValueManager.updateReferenceValue(utils, valueFromTheOutside, prevState.referenceValue),\n        sections: getSectionsFromValue(valueFromTheOutside)\n      }));\n    }\n  }, [valueFromTheOutside]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  React.useEffect(() => {\n    const sections = getSectionsFromValue(state.value);\n    validateSections(sections, valueType);\n    setState(prevState => _extends({}, prevState, {\n      sections\n    }));\n  }, [format, utils.locale]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    state,\n    selectedSectionIndexes,\n    setSelectedSections,\n    clearValue,\n    clearActiveSection,\n    updateSectionValue,\n    updateValueFromValueStr,\n    setTempAndroidValueStr,\n    sectionsValueBoundaries,\n    placeholder\n  };\n};","map":{"version":3,"names":["_extends","React","useControlled","useTheme","useUtils","useLocaleText","useLocalizationContext","addPositionPropertiesToSections","splitFormatIntoSections","clampDaySectionIfPossible","mergeDateIntoReferenceDate","getSectionsBoundaries","validateSections","getDateFromDateSections","useFieldState","params","_ref","utils","localeText","adapter","theme","isRTL","direction","valueManager","fieldValueManager","valueType","validator","internalProps","value","valueProp","defaultValue","onChange","format","selectedSections","selectedSectionsProp","onSelectedSectionsChange","firstDefaultValue","useRef","valueFromTheOutside","current","emptyValue","sectionsValueBoundaries","useMemo","getSectionsFromValue","useCallback","fallbackSections","date","placeholder","getValueStrFromSections","state","setState","useState","sections","referenceValue","updateReferenceValue","getTodayValue","tempValueStrAndroid","innerSetSelectedSections","controlled","default","name","setSelectedSections","newSelectedSections","prevState","selectedSectionQuery","selectedSectionIndexes","startIndex","endIndex","length","shouldSelectBoundarySelectors","selectedSectionIndex","findIndex","section","type","publishValue","context","validationError","props","setSectionValue","sectionIndex","newSectionValue","newSections","modified","clearValue","areValuesEqual","clearActiveSection","activeSection","activeDateManager","getActiveDateManager","nonEmptySectionCountBefore","getSections","filter","isTheOnlyNonEmptySection","newActiveDate","Date","newValues","getNewValuesFromNewActiveDate","isValid","updateValueFromValueStr","valueStr","parseDateStr","dateStr","referenceDate","parse","newValue","parseValueStr","newReferenceValue","updateSectionValue","shouldGoToNextSection","newActiveDateSections","shouldRegenSections","clampedSections","values","shouldPublish","mergedDate","setTempAndroidValueStr","prev","useEffect","locale"],"sources":["D:/SE/myreact/node_modules/@mui/x-date-pickers/internals/hooks/useField/useFieldState.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useControlled from '@mui/utils/useControlled';\nimport { useTheme } from '@mui/material/styles';\nimport { useUtils, useLocaleText, useLocalizationContext } from '../useUtils';\nimport { addPositionPropertiesToSections, splitFormatIntoSections, clampDaySectionIfPossible, mergeDateIntoReferenceDate, getSectionsBoundaries, validateSections, getDateFromDateSections } from './useField.utils';\nexport const useFieldState = params => {\n  var _ref;\n  const utils = useUtils();\n  const localeText = useLocaleText();\n  const adapter = useLocalizationContext();\n  const theme = useTheme();\n  const isRTL = theme.direction === 'rtl';\n  const {\n    valueManager,\n    fieldValueManager,\n    valueType,\n    validator,\n    internalProps,\n    internalProps: {\n      value: valueProp,\n      defaultValue,\n      onChange,\n      format,\n      selectedSections: selectedSectionsProp,\n      onSelectedSectionsChange\n    }\n  } = params;\n  const firstDefaultValue = React.useRef(defaultValue);\n  const valueFromTheOutside = (_ref = valueProp != null ? valueProp : firstDefaultValue.current) != null ? _ref : valueManager.emptyValue;\n  const sectionsValueBoundaries = React.useMemo(() => getSectionsBoundaries(utils), [utils]);\n  const getSectionsFromValue = React.useCallback((value, fallbackSections = null) => fieldValueManager.getSectionsFromValue(utils, value, fallbackSections, isRTL, date => splitFormatIntoSections(utils, localeText, format, date)), [fieldValueManager, format, localeText, isRTL, utils]);\n  const placeholder = React.useMemo(() => fieldValueManager.getValueStrFromSections(getSectionsFromValue(valueManager.emptyValue), isRTL), [fieldValueManager, getSectionsFromValue, valueManager.emptyValue, isRTL]);\n  const [state, setState] = React.useState(() => {\n    const sections = getSectionsFromValue(valueFromTheOutside);\n    validateSections(sections, valueType);\n    return {\n      sections,\n      value: valueFromTheOutside,\n      referenceValue: fieldValueManager.updateReferenceValue(utils, valueFromTheOutside, valueManager.getTodayValue(utils)),\n      tempValueStrAndroid: null\n    };\n  });\n  const [selectedSections, innerSetSelectedSections] = useControlled({\n    controlled: selectedSectionsProp,\n    default: null,\n    name: 'useField',\n    state: 'selectedSectionIndexes'\n  });\n  const setSelectedSections = newSelectedSections => {\n    innerSetSelectedSections(newSelectedSections);\n    onSelectedSectionsChange == null ? void 0 : onSelectedSectionsChange(newSelectedSections);\n    setState(prevState => _extends({}, prevState, {\n      selectedSectionQuery: null\n    }));\n  };\n  const selectedSectionIndexes = React.useMemo(() => {\n    if (selectedSections == null) {\n      return null;\n    }\n    if (selectedSections === 'all') {\n      return {\n        startIndex: 0,\n        endIndex: state.sections.length - 1,\n        shouldSelectBoundarySelectors: true\n      };\n    }\n    if (typeof selectedSections === 'number') {\n      return {\n        startIndex: selectedSections,\n        endIndex: selectedSections\n      };\n    }\n    if (typeof selectedSections === 'string') {\n      const selectedSectionIndex = state.sections.findIndex(section => section.type === selectedSections);\n      return {\n        startIndex: selectedSectionIndex,\n        endIndex: selectedSectionIndex\n      };\n    }\n    return selectedSections;\n  }, [selectedSections, state.sections]);\n  const publishValue = ({\n    value,\n    referenceValue,\n    sections\n  }) => {\n    setState(prevState => _extends({}, prevState, {\n      sections,\n      value,\n      referenceValue,\n      tempValueStrAndroid: null\n    }));\n    if (onChange) {\n      const context = {\n        validationError: validator({\n          adapter,\n          value,\n          props: _extends({}, internalProps, {\n            value\n          })\n        })\n      };\n      onChange(value, context);\n    }\n  };\n  const setSectionValue = (sectionIndex, newSectionValue) => {\n    const newSections = [...state.sections];\n    newSections[sectionIndex] = _extends({}, newSections[sectionIndex], {\n      value: newSectionValue,\n      modified: true\n    });\n    return addPositionPropertiesToSections(newSections, isRTL);\n  };\n  const clearValue = () => {\n    if (valueManager.areValuesEqual(utils, state.value, valueManager.emptyValue)) {\n      return;\n    }\n    publishValue({\n      value: valueManager.emptyValue,\n      referenceValue: state.referenceValue,\n      sections: getSectionsFromValue(valueManager.emptyValue)\n    });\n  };\n  const clearActiveSection = () => {\n    if (selectedSectionIndexes == null) {\n      return;\n    }\n    const activeSection = state.sections[selectedSectionIndexes.startIndex];\n    if (activeSection.value === '') {\n      return;\n    }\n    const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);\n    const nonEmptySectionCountBefore = activeDateManager.getSections(state.sections).filter(section => section.value !== '').length;\n    const isTheOnlyNonEmptySection = nonEmptySectionCountBefore === 1;\n    const newSections = setSectionValue(selectedSectionIndexes.startIndex, '');\n    const newActiveDate = isTheOnlyNonEmptySection ? null : utils.date(new Date(''));\n    const newValues = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);\n    if ((newActiveDate != null && !utils.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils.isValid(activeDateManager.date))) {\n      publishValue(_extends({}, newValues, {\n        sections: newSections\n      }));\n    } else {\n      setState(prevState => _extends({}, prevState, newValues, {\n        sections: newSections,\n        tempValueStrAndroid: null\n      }));\n    }\n  };\n  const updateValueFromValueStr = valueStr => {\n    const parseDateStr = (dateStr, referenceDate) => {\n      const date = utils.parse(dateStr, format);\n      if (date == null || !utils.isValid(date)) {\n        return null;\n      }\n      const sections = splitFormatIntoSections(utils, localeText, format, date);\n      return mergeDateIntoReferenceDate(utils, date, sections, referenceDate, false);\n    };\n    const newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);\n    const newReferenceValue = fieldValueManager.updateReferenceValue(utils, newValue, state.referenceValue);\n    publishValue({\n      value: newValue,\n      referenceValue: newReferenceValue,\n      sections: getSectionsFromValue(newValue, state.sections)\n    });\n  };\n  const updateSectionValue = ({\n    activeSection,\n    newSectionValue,\n    shouldGoToNextSection\n  }) => {\n    /**\n     * 1. Decide which section should be focused\n     */\n    if (shouldGoToNextSection && selectedSectionIndexes && selectedSectionIndexes.startIndex < state.sections.length - 1) {\n      setSelectedSections(selectedSectionIndexes.startIndex + 1);\n    } else if (selectedSectionIndexes && selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n      setSelectedSections(selectedSectionIndexes.startIndex);\n    }\n\n    /**\n     * 2. Try to build a valid date from the new section value\n     */\n    const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);\n    const newSections = setSectionValue(selectedSectionIndexes.startIndex, newSectionValue);\n    const newActiveDateSections = activeDateManager.getSections(newSections);\n    let newActiveDate = getDateFromDateSections(utils, newActiveDateSections);\n    let shouldRegenSections = false;\n\n    /**\n     * If the date is invalid,\n     * Then we can try to clamp the day section to see if that produces a valid date.\n     * This can be useful if the month has fewer days than the day value currently provided.\n     */\n    if (!utils.isValid(newActiveDate)) {\n      const clampedSections = clampDaySectionIfPossible(utils, newActiveDateSections, sectionsValueBoundaries);\n      if (clampedSections != null) {\n        shouldRegenSections = true;\n        newActiveDate = getDateFromDateSections(utils, clampedSections);\n      }\n    }\n    let values;\n    let shouldPublish;\n\n    /**\n     * If the new date is valid,\n     * Then we merge the value of the modified sections into the reference date.\n     * This makes sure that we don't lose some information of the initial date (like the time on a date field).\n     */\n    if (newActiveDate != null && utils.isValid(newActiveDate)) {\n      const mergedDate = mergeDateIntoReferenceDate(utils, newActiveDate, newActiveDateSections, activeDateManager.referenceDate, true);\n      values = activeDateManager.getNewValuesFromNewActiveDate(mergedDate);\n      shouldPublish = true;\n    } else {\n      values = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);\n      shouldPublish = (newActiveDate != null && !utils.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils.isValid(activeDateManager.date));\n    }\n\n    /**\n     * If the value has been modified (to clamp the day).\n     * Then we need to re-generate the sections to make sure they also have this change.\n     */\n    const sections = shouldRegenSections ? getSectionsFromValue(values.value, state.sections) : newSections;\n\n    /**\n     * Publish or update the internal state with the new value and sections.\n     */\n    if (shouldPublish) {\n      return publishValue(_extends({}, values, {\n        sections\n      }));\n    }\n    return setState(prevState => _extends({}, prevState, values, {\n      sections,\n      tempValueStrAndroid: null\n    }));\n  };\n  const setTempAndroidValueStr = tempValueStrAndroid => setState(prev => _extends({}, prev, {\n    tempValueStrAndroid\n  }));\n  React.useEffect(() => {\n    if (!valueManager.areValuesEqual(utils, state.value, valueFromTheOutside)) {\n      setState(prevState => _extends({}, prevState, {\n        value: valueFromTheOutside,\n        referenceValue: fieldValueManager.updateReferenceValue(utils, valueFromTheOutside, prevState.referenceValue),\n        sections: getSectionsFromValue(valueFromTheOutside)\n      }));\n    }\n  }, [valueFromTheOutside]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  React.useEffect(() => {\n    const sections = getSectionsFromValue(state.value);\n    validateSections(sections, valueType);\n    setState(prevState => _extends({}, prevState, {\n      sections\n    }));\n  }, [format, utils.locale]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    state,\n    selectedSectionIndexes,\n    setSelectedSections,\n    clearValue,\n    clearActiveSection,\n    updateSectionValue,\n    updateValueFromValueStr,\n    setTempAndroidValueStr,\n    sectionsValueBoundaries,\n    placeholder\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}